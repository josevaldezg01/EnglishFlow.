<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>English Learning Control - Fixed</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
.word {
    transition: all 0.3s ease;
    cursor: pointer;
    border-radius: 4px;
    padding: 1px 2px;
    margin: 0;
    display: inline;
    position: relative;
    white-space: nowrap;
}

.word:hover {
    background-color: #e2e8f0;
}

.known {
    background-color: #bbf7d0;
    padding: 2px 4px;
}

.forgotten {
    background-color: #fed7aa;
    padding: 2px 4px;
}

.word-actions {
    display: inline-flex;
    gap: 2px;
    margin-left: 4px;
    opacity: 1;
    transition: opacity 0.2s ease;
    vertical-align: middle;
}

.word-actions button {
    padding: 2px 4px;
    font-size: 0.8rem;
    border-radius: 3px;
    border: 1px solid transparent;
    transition: all 0.2s ease;
    min-width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

.text-display {
    line-height: 2.1;
    font-size: 1.1rem;
}

.word-actions button:hover {
    transform: scale(1.1);
}

.speech-btn {
    background-color: #dbeafe;
    color: #1e40af;
    border-color: #93c5fd;
}

.speech-btn:hover {
    background-color: #bfdbfe;
    border-color: #60a5fa;
}

.mark-known-btn {
    background-color: #dcfce7;
    color: #166534;
    border-color: #86efac;
}

.mark-known-btn:hover {
    background-color: #bbf7d0;
    border-color: #4ade80;
}

.mark-forgotten-btn {
    background-color: #fed7aa;
    color: #c2410c;
    border-color: #fdba74;
}

.mark-forgotten-btn:hover {
    background-color: #fb923c;
    border-color: #f97316;
}

#textInput {
    min-height: 150px;
}

.login-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.login-box {
    background-color: white;
    padding: 2rem;
    border-radius: 0.5rem;
    width: 100%;
    max-width: 400px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

#practiceWords {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1rem;
    width: 100%;
}

.practice-word-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    border: 2px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    transition: all 0.3s ease;
}

.practice-word-card:hover {
    border-color: #6366f1;
    transform: translateY(-2px);
    box-shadow: 0 8px 12px rgba(0,0,0,0.15);
}

.word-original {
    font-weight: bold;
    font-size: 1.25rem;
    color: #1f2937;
    text-align: center;
}

.word-translation {
    font-style: italic;
    color: #6b7280;
    font-size: 1rem;
    text-align: center;
    border-top: 1px solid #e5e7eb;
    padding-top: 0.5rem;
}

.practice-card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: auto;
    justify-content: center;
}

.practice-card-actions button {
    padding: 0.5rem;
    border-radius: 8px;
    border: 1px solid transparent;
    transition: all 0.2s ease;
    font-size: 0.875rem;
}

.speak-practice-btn {
    background: #dbeafe;
    color: #1e40af;
}

.speak-practice-btn:hover {
    background: #bfdbfe;
}

.mark-practice-known-btn {
    background: #dcfce7;
    color: #166534;
}

.mark-practice-known-btn:hover {
    background: #bbf7d0;
}

.loading-card {
    display: flex;
    align-items: center;
    justify-content: center;
    color: #6b7280;
    font-style: italic;
}
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Login Section -->
    <div id="loginContainer" class="login-container">
        <div class="login-box">
            <h2 class="text-2xl font-bold text-center text-indigo-700 mb-6">English Learning Login</h2>
            <div class="space-y-4">
                <div>
                    <label for="username" class="block text-sm font-medium text-gray-700 mb-1">Username</label>
                    <input type="text" id="username" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="password" class="block text-sm font-medium text-gray-700 mb-1">Password</label>
                    <input type="password" id="password" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <button id="loginBtn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition">
                    Login
                </button>
                <p id="loginError" class="text-red-500 text-sm text-center hidden">Invalid username or password</p>
            </div>
        </div>
    </div>

    <div id="mainApp" class="container mx-auto px-4 py-8" style="display: none;">
        <header class="mb-10 text-center">
            <h1 class="text-4xl font-bold text-indigo-700 mb-2">English Learning Control</h1>
            <p class="text-lg text-gray-600">Track your English vocabulary progress and practice effectively</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column - Text Management -->
            <div class="lg:col-span-2 space-y-8">
                <!-- Section 1: Add New Text -->
                <section class="bg-white rounded-xl shadow-md p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Add New Text</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="textName" class="block text-sm font-medium text-gray-700 mb-1">Text Name</label>
                            <input type="text" id="textName" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="textInput" class="block text-sm font-medium text-gray-700 mb-1">Paste English Text</label>
                            <textarea id="textInput" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>
                        <button id="saveTextBtn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition flex items-center justify-center">
                            <i class="fas fa-save mr-2"></i> Save Text
                        </button>
                    </div>
                </section>

                <!-- Section 2: Saved Texts -->
                <section class="bg-white rounded-xl shadow-md p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Saved Texts</h2>
                    <div class="space-y-4">
                        <div id="savedTextsList" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <!-- Saved texts will appear here -->
                        </div>
                    </div>
                </section>

                <!-- Section 3: Text Viewer -->
                <section id="textViewerSection" class="bg-white rounded-xl shadow-md p-6 hidden">
                    <div class="flex justify-between items-center mb-4">
                        <h2 id="currentTextTitle" class="text-2xl font-semibold text-gray-800"></h2>
                        <button id="closeTextViewer" class="text-gray-500 hover:text-gray-700">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg mb-4">
                        <div id="textDisplay" class="text-display"></div>
                    </div>
                    <div id="translationResult" class="hidden bg-gray-100 p-3 rounded-lg"></div>
                </section>
            </div>

            <!-- Right Column - Stats and Practice -->
            <div class="space-y-8">
                <!-- Section 4: Vocabulary Stats -->
                <section class="bg-white rounded-xl shadow-md p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Vocabulary Progress</h2>
                    <div class="space-y-6">
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="text-sm font-medium text-gray-700">Learning Progress</span>
                                <span id="progressPercentage" class="text-sm font-medium text-gray-700">0%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5">
                                <div id="progressBar" class="progress-bar bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="bg-green-50 p-3 rounded-lg">
                                <p class="text-sm text-gray-600">Known Words</p>
                                <p id="knownCount" class="text-2xl font-bold text-green-600">0</p>
                            </div>
                            <div class="bg-orange-50 p-3 rounded-lg">
                                <p class="text-sm text-gray-600">Forgotten Words</p>
                                <p id="forgottenCount" class="text-2xl font-bold text-orange-600">0</p>
                            </div>
                            <div class="bg-blue-50 p-3 rounded-lg">
                                <p class="text-sm text-gray-600">Total Words</p>
                                <p id="totalCount" class="text-2xl font-bold text-blue-600">0</p>
                            </div>
                            <div class="bg-purple-50 p-3 rounded-lg">
                                <p class="text-sm text-gray-600">Texts Saved</p>
                                <p id="textsCount" class="text-2xl font-bold text-purple-600">0</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Section 5: Word Inventory -->
                <section class="bg-white rounded-xl shadow-md p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Word Inventory</h2>
                    <div class="space-y-4">
                        <div class="flex items-center space-x-2">
                            <input type="text" id="searchWord" placeholder="Search words..." class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                            <button id="searchBtn" class="bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                        <div class="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-2">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Word</th>
                                        <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                    </tr>
                                </thead>
                                <tbody id="wordInventory" class="bg-white divide-y divide-gray-200">
                                    <!-- Words will appear here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <!-- Section 6: Practice Words -->
                <section class="bg-white rounded-xl shadow-md p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Practice Words</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="wordCount" class="block text-sm font-medium text-gray-700 mb-1">Number of Words to Practice</label>
                            <input type="number" id="wordCount" min="1" max="20" value="5" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <button id="generatePracticeBtn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition flex items-center justify-center">
                            <i class="fas fa-dumbbell mr-2"></i> Generate Practice List
                        </button>
                        
                        <div id="practiceList" class="hidden space-y-4 mt-4">
                            <h3 class="text-lg font-medium text-gray-800">Your Practice Words:</h3>
                            <div id="practiceWords"></div>
                            
                            <div class="flex flex-wrap gap-2 mt-4">
                                <button id="markAllKnown" class="flex-1 min-w-[120px] bg-green-100 text-green-800 px-3 py-2 rounded-lg hover:bg-green-200 flex items-center justify-center">
                                    <i class="fas fa-check-double mr-1"></i> Mark All Known
                                </button>
                                <button id="shufflePractice" class="flex-1 min-w-[120px] bg-gray-100 text-gray-800 px-3 py-2 rounded-lg hover:bg-gray-200 flex items-center justify-center">
                                    <i class="fas fa-random mr-1"></i> Shuffle
                                </button>
                                <button id="playPracticeLoop" class="flex-1 min-w-[120px] bg-blue-100 text-blue-800 px-3 py-2 rounded-lg hover:bg-blue-200 flex items-center justify-center">
                                    <i class="fas fa-play-circle mr-1"></i> Listen All
                                </button>
                                <button id="downloadPracticeAudio" class="flex-1 min-w-[120px] bg-purple-100 text-purple-800 px-3 py-2 rounded-lg hover:bg-purple-200 flex items-center justify-center">
                                <i class="fas fa-download mr-1"></i> Download MP3
                                </button>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURACIÓN SUPABASE ==========
        let supabase;
        
        // Intentar inicializar Supabase
        try {
            const SUPABASE_URL = 'https://cxtresumeeybaksjtaqs.supabase.co';
            const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN4dHJlc3VtZWV5YmFrc2p0YXFzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMzE5ODgsImV4cCI6MjA2ODYwNzk4OH0.oo1l7GeAJQOGzM9nMgzFYrxwKNIU9x0B0RJlx7ShSOM';
            
            if (window.supabase && window.supabase.createClient) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                console.log('Supabase inicializado correctamente');
            } else {
                throw new Error('Supabase library not loaded');
            }
        } catch (error) {
            console.error('Error inicializando Supabase:', error);
        }

        // ========== VARIABLES GLOBALES ==========
        const users = {
            "Jose": "Taliana123",
            "Taliana": "Taliana123",
            "Test": "Taliana123"
        };
        let currentUser = null;
        let texts = [];
        let wordInventory = {};
        let selectedText = null;
        let selectedWord = null;
        let selectedRange = null;
        let currentPracticeWords = [];

        // ========== ELEMENTOS DEL DOM ==========
        let usernameInput, passwordInput, loginBtn, loginError, loginContainer, mainApp;
        let saveTextBtn, textNameInput, textInput, savedTextsList, textViewerSection;
        let currentTextTitle, textDisplay, closeTextViewer, translationResult;
        let knownCount, forgottenCount, totalCount, textsCount, progressBar, progressPercentage;
        let wordInventoryTable, searchWord, searchBtn, wordCount, generatePracticeBtn;
        let practiceList, practiceWords, markAllKnown, shufflePractice, playPracticeLoop;
        let downloadPracticeAudio;

        // ========== FUNCIÓN DE INICIALIZACIÓN DOM ==========
        function initializeDOMElements() {
            // Login elements
            usernameInput = document.getElementById('username');
            passwordInput = document.getElementById('password');
            loginBtn = document.getElementById('loginBtn');
            loginError = document.getElementById('loginError');
            loginContainer = document.getElementById('loginContainer');
            mainApp = document.getElementById('mainApp');
            downloadPracticeAudio = document.getElementById('downloadPracticeAudio');
            
            // Text management elements
            saveTextBtn = document.getElementById('saveTextBtn');
            textNameInput = document.getElementById('textName');
            textInput = document.getElementById('textInput');
            savedTextsList = document.getElementById('savedTextsList');
            textViewerSection = document.getElementById('textViewerSection');
            currentTextTitle = document.getElementById('currentTextTitle');
            textDisplay = document.getElementById('textDisplay');
            closeTextViewer = document.getElementById('closeTextViewer');
            translationResult = document.getElementById('translationResult');
            
            // Stats elements
            knownCount = document.getElementById('knownCount');
            forgottenCount = document.getElementById('forgottenCount');
            totalCount = document.getElementById('totalCount');
            textsCount = document.getElementById('textsCount');
            progressBar = document.getElementById('progressBar');
            progressPercentage = document.getElementById('progressPercentage');
            
            // Inventory elements
            wordInventoryTable = document.getElementById('wordInventory');
            searchWord = document.getElementById('searchWord');
            searchBtn = document.getElementById('searchBtn');
            
            // Practice elements
            wordCount = document.getElementById('wordCount');
            generatePracticeBtn = document.getElementById('generatePracticeBtn');
            practiceList = document.getElementById('practiceList');
            practiceWords = document.getElementById('practiceWords');
            markAllKnown = document.getElementById('markAllKnown');
            shufflePractice = document.getElementById('shufflePractice');
            playPracticeLoop = document.getElementById('playPracticeLoop');
            
            console.log('DOM elements initialized');
        }

        // ========== FUNCIONES DE LOGIN ==========
        function initLogin() {
            if (!loginBtn || !passwordInput || !loginContainer || !mainApp) {
                console.error("Error: Elementos críticos del login no encontrados");
                return;
            }
            
            loginBtn.addEventListener('click', handleLogin);
            passwordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleLogin();
            });
            
            console.log('Login initialized');
        }

        async function handleLogin() {
            const username = usernameInput.value.trim();
            const password = passwordInput.value;

            console.log('Attempting login for:', username);

            if (users[username] && users[username] === password) {
                currentUser = username;
                console.log('Login successful for:', currentUser);
                
                loginContainer.style.display = 'none';
                mainApp.style.display = 'block';

                await initApp();
            } else {
                console.log('Login failed - invalid credentials');
                loginError.classList.remove('hidden');
                setTimeout(() => {
                    loginError.classList.add('hidden');
                }, 3000);
            }
        }

        // ========== FUNCIONES DE APLICACIÓN ==========
        async function initApp() {
            console.log('Initializing app for user:', currentUser);
            
            try {
                // Usar datos simulados si Supabase no está disponible
                if (!supabase) {
                    console.warn('Using simulated data - Supabase not available');
                    initSimulatedData();
                } else {
                    await renderSavedTexts();
                    await updateStats();
                    await renderWordInventory();
                }
                
                // Event listeners
                if (saveTextBtn) saveTextBtn.addEventListener('click', saveText);
                if (closeTextViewer) closeTextViewer.addEventListener('click', closeText);
                if (searchBtn) searchBtn.addEventListener('click', searchWords);
                if (downloadPracticeAudio) downloadPracticeAudio.addEventListener('click', generateAndDownloadPracticeAudio);

                // Practice events
                if (generatePracticeBtn) generatePracticeBtn.addEventListener('click', generatePracticeList);
                if (markAllKnown) markAllKnown.addEventListener('click', markAllPracticeWordsAsKnown);
                if (shufflePractice) shufflePractice.addEventListener('click', shufflePracticeWords);
                if (playPracticeLoop) playPracticeLoop.addEventListener('click', playAllPracticeWords);
                
                console.log('App initialized successfully');
                
            } catch (error) {
                console.error('Error initializing app:', error);
            }
        }

        function initSimulatedData() {
            texts = [
                {
                    name: "Sample Text 1",
                    content: "This is a sample English text for testing purposes. You can practice with these words and learn new vocabulary.",
                    created_at: new Date().toISOString()
                },
                {
                    name: "Sample Text 2", 
                    content: "Learning English requires practice and patience. Every word you study helps improve your language skills.",
                    created_at: new Date().toISOString()
                }
            ];
            
            // Inventario ampliado con verbos irregulares
            wordInventory = {
                // Palabras básicas
                "sample": { status: "new" },
                "english": { status: "known" },
                "text": { status: "forgotten" },
                "testing": { status: "new" },
                "practice": { status: "new" },
                "learning": { status: "new" },
                "requires": { status: "forgotten" },
                "patience": { status: "new" },
                "every": { status: "new" },
                "word": { status: "forgotten" },
                "study": { status: "new" },
                "helps": { status: "new" },
                "improve": { status: "forgotten" },
                "language": { status: "new" },
                "skills": { status: "new" },
                "vocabulary": { status: "new" },
                "hello": { status: "new" },
                "world": { status: "forgotten" },
                "computer": { status: "new" },
                "science": { status: "new" },
                "technology": { status: "forgotten" },
                "internet": { status: "new" },
                "website": { status: "new" },
                "application": { status: "forgotten" },
                "program": { status: "new" },
                
                // Verbos irregulares para práctica
                "awake": { status: "new" },
                "be": { status: "forgotten" },
                "bear": { status: "new" },
                "beat": { status: "new" },
                "become": { status: "forgotten" },
                "bend": { status: "new" },
                "blow": { status: "new" },
                "bring": { status: "forgotten" },
                "broadcast": { status: "new" },
                "buy": { status: "new" },
                "catch": { status: "forgotten" },
                "choose": { status: "new" },
                "come": { status: "new" },
                "cut": { status: "forgotten" },
                "dig": { status: "new" },
                "do": { status: "new" },
                "draw": { status: "forgotten" },
                "drive": { status: "new" },
                "drink": { status: "new" },
                "eat": { status: "forgotten" },
                "fall": { status: "new" },
                "feed": { status: "new" },
                "feel": { status: "forgotten" },
                "fight": { status: "new" },
                "find": { status: "new" },
                "fly": { status: "forgotten" },
                "forget": { status: "new" },
                "forgive": { status: "new" },
                "get": { status: "forgotten" },
                "give": { status: "new" },
                "grind": { status: "new" },
                "go": { status: "forgotten" },
                "have": { status: "new" },
                "hear": { status: "new" },
                "hide": { status: "forgotten" },
                "hit": { status: "new" },
                "hold": { status: "new" },
                "keep": { status: "forgotten" },
                "know": { status: "new" },
                "lay": { status: "new" },
                "learn": { status: "forgotten" },
                "leave": { status: "new" },
                "let": { status: "new" },
                "lie": { status: "forgotten" },
                "lose": { status: "new" },
                "make": { status: "new" },
                "mean": { status: "forgotten" },
                "meet": { status: "new" },
                "pay": { status: "new" },
                "put": { status: "forgotten" },
                "quit": { status: "new" },
                "read": { status: "new" },
                "run": { status: "forgotten" },
                "say": { status: "new" },
                "see": { status: "new" },
                "seek": { status: "forgotten" },
                "sell": { status: "new" },
                "send": { status: "new" },
                "shake": { status: "forgotten" },
                "show": { status: "new" },
                "sing": { status: "new" },
                "sink": { status: "forgotten" },
                "sit": { status: "new" },
                "sleep": { status: "new" },
                "slide": { status: "forgotten" },
                "sow": { status: "new" },
                "speak": { status: "new" },
                "spend": { status: "forgotten" },
                "spin": { status: "new" },
                "stand": { status: "new" }
            };
            
            renderSavedTexts();
            updateStats();
            renderWordInventory();
        }

               // ========== FUNCIONES DE TRADUCCIÓN ==========
        async function translateWordToSpanish(word) {
        if (!word || word.trim() === '') return { general: '' };

        const multiMeaningDict = {

        'bear': {
            sustantivo: 'oso / osa',
            verbo: 'soportar / aguantar'
        },
        'bat': {
            sustantivo: 'murciélago / bate',
            verbo: 'batear / golpear'
        },
        'book': {
            sustantivo: 'libro',
            verbo: 'reservar / anotar'
        },
        'can': {
            sustantivo: 'lata / bote',
            verbo: 'poder / ser capaz'
        },
        'fire': {
            sustantivo: 'fuego / incendio',
            verbo: 'disparar / despedir'
        },
        'hand': {
            sustantivo: 'mano',
            verbo: 'entregar / pasar'
        },
        'head': {
            sustantivo: 'cabeza',
            verbo: 'dirigir / encabezar'
        },
        'light': {
            sustantivo: 'luz / lámpara',
            verbo: 'encender / iluminar'
        },
        'plant': {
            sustantivo: 'planta',
            verbo: 'plantar / sembrar'
        },
        'point': {
            sustantivo: 'punto / punta',
            verbo: 'señalar / apuntar'
        },
        'rock': {
            sustantivo: 'roca / piedra',
            verbo: 'mecer / balancear'
        },
        'run': {
            sustantivo: 'carrera / corrida',
            verbo: 'correr / funcionar'
        },
        'fly': {
            sustantivo: 'mosca',
            verbo: 'volar'
        },
        'watch': {
            sustantivo: 'reloj',
            verbo: 'mirar / observar'
        },
        'water': {
            sustantivo: 'agua',
            verbo: 'regar / dar agua'
        },
        'work': {
            sustantivo: 'trabajo / obra',
            verbo: 'trabajar / funcionar'
        },
        'play': {
            sustantivo: 'juego / obra teatral',
            verbo: 'jugar / tocar'
        },
        'rest': {
            sustantivo: 'descanso / resto',
            verbo: 'descansar / apoyar'
        },
        'park': {
            sustantivo: 'parque',
            verbo: 'aparcar / estacionar'
        },
        'fish': {
            sustantivo: 'pez / pescado',
            verbo: 'pescar'
        },
        'place': {
            sustantivo: 'lugar / sitio',
            verbo: 'colocar / poner'
        },
        'train': {
            sustantivo: 'tren',
            verbo: 'entrenar / formar'
        },
        'ship': {
            sustantivo: 'barco / nave',
            verbo: 'enviar / embarcar'
        },
        'picture': {
            sustantivo: 'imagen / foto',
            verbo: 'imaginar / representar'
        },
        'show': {
            sustantivo: 'espectáculo / programa',
            verbo: 'mostrar / enseñar'
         },
        'matter': {
            sustantivo: 'asunto  / cuestión',
            verbo: 'importar  / importancia'
         },

        // Verbos solo verbos
        'be': { verbo: 'ser / estar' },
        'have': { verbo: 'tener' },
        'do': { verbo: 'hacer' },
        'say': { verbo: 'decir' },
'get': { verbo: 'obtener / conseguir' },
'make': { verbo: 'hacer / crear' },
'go': { verbo: 'ir' },
'know': { verbo: 'saber / conocer' },
'take': { verbo: 'tomar / llevar' },
'see': { verbo: 'ver' },
'come': { verbo: 'venir' },
'think': { verbo: 'pensar' },
'look': { verbo: 'mirar / buscar' },
'want': { verbo: 'querer' },
'give': { verbo: 'dar' },
'use': { verbo: 'usar' },
'find': { verbo: 'encontrar' },
'tell': { verbo: 'decir / contar' },
'ask': { verbo: 'preguntar' },
'seem': { verbo: 'parecer' },
'feel': { verbo: 'sentir' },
'try': { verbo: 'intentar / probar' },
'leave': { verbo: 'salir / dejar' },
'call': { verbo: 'llamar' },
'read': { verbo: 'leer' },
'write': { verbo: 'escribir' },
'move': { verbo: 'mover / mudarse' },
'live': { verbo: 'vivir' },
'believe': { verbo: 'creer' },
'bring': { verbo: 'traer' },
'happen': { verbo: 'pasar / ocurrir' },
'must': { verbo: 'deber / tener que' },
'put': { verbo: 'poner' },
'mean': { verbo: 'significar' },
'become': { verbo: 'convertirse / llegar a ser' },
'keep': { verbo: 'mantener / guardar' },
'let': { verbo: 'dejar / permitir' },
'begin': { verbo: 'empezar / comenzar' },
'help': { verbo: 'ayudar' },
'talk': { verbo: 'hablar / conversar' },
'turn': { verbo: 'girar / convertir' },
'start': { verbo: 'empezar / arrancar' },
'might': { verbo: 'poder / tal vez' },
'hear': { verbo: 'oír / escuchar' },
'hold': { verbo: 'sostener / celebrar' },
'provide': { verbo: 'proporcionar' },
'sit': { verbo: 'sentarse' },
'stand': { verbo: 'estar de pie / soportar' },
'lose': { verbo: 'perder' },
'pay': { verbo: 'pagar' },
'meet': { verbo: 'conocer / encontrarse' },
'include': { verbo: 'incluir' },
'continue': { verbo: 'continuar' },
'set': { verbo: 'poner / establecer' },
'learn': { verbo: 'aprender' },
'change': { verbo: 'cambiar' },
'lead': { verbo: 'liderar / conducir' },
'understand': { verbo: 'entender' },
'follow': { verbo: 'seguir' },
'stop': { verbo: 'parar / detener' },
'create': { verbo: 'crear' },
'speak': { verbo: 'hablar' },
'spend': { verbo: 'gastar / pasar tiempo' },
'grow': { verbo: 'crecer / cultivar' },
'open': { verbo: 'abrir' },
'walk': { verbo: 'caminar' },
'win': { verbo: 'ganar' },
'offer': { verbo: 'ofrecer' },
'remember': { verbo: 'recordar' },
'consider': { verbo: 'considerar' },
'appear': { verbo: 'aparecer / parecer' },
'buy': { verbo: 'comprar' },
'wait': { verbo: 'esperar' },
'serve': { verbo: 'servir' },
'die': { verbo: 'morir' },
'send': { verbo: 'enviar' },
'expect': { verbo: 'esperar' },
'build': { verbo: 'construir' },
'stay': { verbo: 'quedarse' },
'fall': { verbo: 'caer' },
'cut': { verbo: 'cortar' },
'reach': { verbo: 'alcanzar' },
'kill': { verbo: 'matar' },
'remain': { verbo: 'permanecer' },
'awake': { verbo: 'despertar' },
'beat': { verbo: 'golpear / vencer' },
'bend': { verbo: 'doblar / curvar' },
'blow': { verbo: 'soplar' },
'broadcast': { verbo: 'transmitir / difundir' },
'catch': { verbo: 'atrapar / coger' },
'choose': { verbo: 'elegir / escoger' },
'dig': { verbo: 'cavar / excavar' },
'draw': { verbo: 'dibujar / tirar' },
'drive': { verbo: 'conducir / manejar' },
'drink': { verbo: 'beber' },
'eat': { verbo: 'comer' },
'feed': { verbo: 'alimentar / dar de comer' },
'fight': { verbo: 'luchar / pelear' },
'forget': { verbo: 'olvidar' },
'forgive': { verbo: 'perdonar' },
'grind': { verbo: 'moler / triturar' },
'hide': { verbo: 'esconder / ocultar' },
'hit': { verbo: 'golpear / pegar' },
'lay': { verbo: 'poner / colocar' },
'lie': { verbo: 'mentir / acostarse' },
'quit': { verbo: 'dejar / renunciar' },
'seek': { verbo: 'buscar / procurar' },
'sell': { verbo: 'vender' },
'shake': { verbo: 'sacudir / temblar' },
'sing': { verbo: 'cantar' },
'sink': { verbo: 'hundir / sumergir' },
'sleep': { verbo: 'dormir' },
'slide': { verbo: 'deslizar / resbalar' },
'sow': { verbo: 'sembrar' },
'spin': { verbo: 'girar / hilar' },


                // Palabras solo con un significado principal
                'hello': { general: 'hola' },
                'world': { general: 'mundo' },
                'test': { general: 'prueba' },
                'sample': { general: 'muestra' },
                'english': { general: 'inglés' },
                'text': { general: 'texto' },
                'practice': { general: 'práctica' },
                'word': { general: 'palabra' },
                'testing': { general: 'probando' },
                'learning': { general: 'aprendizaje' },
                'patience': { general: 'paciencia' },
                'every': { general: 'cada' },
                'language': { general: 'idioma' },
                'skills': { general: 'habilidades' },
                'vocabulary': { general: 'vocabulario' },
                'computer': { general: 'computadora' },
                'science': { general: 'ciencia' },
                'technology': { general: 'tecnología' },
                'internet': { general: 'internet' },
                'website': { general: 'sitio web' },
                'application': { general: 'aplicación' },
                'program': { general: 'programa' },
                'this': { general: 'esto' },
                'for': { general: 'para' },
                'purposes': { general: 'propósitos' },
                'you': { general: 'tú' },
                'with': { general: 'con' },
                'these': { general: 'estas' },
                'words': { general: 'palabras' },
                'and': { general: 'y' },
                'new': { general: 'nuevo' },
                'cat': { general: 'gato' },
                'dog': { general: 'perro' },
                'house': { general: 'casa' },
                'car': { general: 'coche' },
                'table': { general: 'mesa' },
                'chair': { general: 'silla' },
                'food': { general: 'comida' },
                'money': { general: 'dinero' },
                'time': { general: 'tiempo' },
                'person': { general: 'persona' },
                'family': { general: 'familia' },
                'friend': { general: 'amigo' },
                'school': { general: 'escuela' },
                'love': { general: 'amor' },
                'life': { general: 'vida' },
                'health': { general: 'salud' },
              // adjetivos / verbos que no he catalogado
                'frightening': { general: 'aterrador / espantoso' },
                'gotta': { general: 'tener que' },
                'hush': { general: 'callate / silencio' },
                'losin': { general: 'Perdiendo' },
                'inviting': { atractivo: 'tentador' },
};

// 1. Primero busca en tu diccionario local
    const wordLower = word.toLowerCase();
    const localResult = multiMeaningDict[wordLower];
    if (localResult) {
        console.log('Traducción encontrada en diccionario local');
        return localResult;
    }

    // 2. Si no está, usa MyMemory API
    console.log('Buscando en MyMemory API:', word);
    try {
        const response = await fetch(
            `https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|es`
        );

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        const translatedText = data.responseData?.translatedText || word;

        // Guarda la nueva traducción en el diccionario local
        if (translatedText !== word) {
            multiMeaningDict[wordLower] = { general: translatedText };
            console.log('Nueva traducción guardada:', word, '->', translatedText);
        }

        return { general: translatedText, source: 'mymemory' };

    } catch (error) {
        console.error('Error con MyMemory API:', error);
        return { general: word, source: 'none' }; // Fallback a palabra original
    }
}

function formatTranslation(meaningObj) {
    const extractCleanText = (text) => {
        if (!text) return '';
        return text.replace(/<[^>]+>/g, '').replace(/\s*\/\s*/g, ', ');
    };

    let htmlResult = '';
    let plainTextResult = '';

    // Manejar tanto "sustantivo/noun" como "verbo/verb" para compatibilidad
    const hasNoun = meaningObj.sustantivo || meaningObj.noun;
    const hasVerb = meaningObj.verbo || meaningObj.verb;

    if (hasNoun && hasVerb) {
        const nounText = meaningObj.sustantivo || meaningObj.noun;
        const verbText = meaningObj.verbo || meaningObj.verb;

        htmlResult = `<div class="text-sm"><strong>sust.</strong> ${nounText}</div><div class="text-sm mt-1"><strong>verb.</strong> ${verbText}</div>`;
        plainTextResult = `Sustantivo: ${extractCleanText(nounText)}. Verbo: ${extractCleanText(verbText)}`;
    }
    else if (hasNoun) {
        const nounText = meaningObj.sustantivo || meaningObj.noun;
        htmlResult = `<div class="text-sm"><strong>sust.</strong> ${nounText}</div>`;
        plainTextResult = `Sustantivo: ${extractCleanText(nounText)}`;
    }
    else if (hasVerb) {
        const verbText = meaningObj.verbo || meaningObj.verb;
        htmlResult = `<div class="text-sm"><strong>verb.</strong> ${verbText}</div>`;
        plainTextResult = `Verbo: ${extractCleanText(verbText)}`;
    }
    else {
        const text = meaningObj.general || Object.values(meaningObj)[0];
        htmlResult = `<div class="text-sm">${text}</div>`;
        plainTextResult = extractCleanText(text);
    }

    return {
        html: htmlResult,
        text: plainTextResult
    };
}

// ========== FUNCIONES AUXILIARES ==========
let learningMode = true; // Si está activo, guarda nuevas palabras automáticamente

async function translateWithLibreTranslate(word) {
    const LIBRETRANSLATE_API = 'https://libretranslate.de/translate';
    const PROXY_URL = 'https://corsproxy.io/?'; // Proxy alternativo confiable

    // Configuración base para la petición
    const requestOptions = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        },
        body: JSON.stringify({
            q: word,
            source: 'en',
            target: 'es',
            format: 'text'
        })
    };

    try {
        // Intento 1: Petición directa (funciona en servidores con CORS habilitado)
        let response = await fetch(LIBRETRANSLATE_API, requestOptions);

        // Si falla por CORS, usamos proxy
        if (!response.ok || response.status === 0) {
            console.log('Usando proxy CORS...');
            response = await fetch(PROXY_URL + encodeURIComponent(LIBRETRANSLATE_API), {
                ...requestOptions,
                headers: {
                    ...requestOptions.headers,
                    'X-Requested-With': 'XMLHttpRequest' // Algunos proxies lo requieren
                }
            });
        }

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        return data.translatedText || word;

    } catch (error) {
        console.error('Error de traducción:', error);
        return word; // Fallback seguro
    }
}

function addToLocalDictionary(word, translation) {
    if (!learningMode) return;

    const wordLower = word.toLowerCase();
    // Evitar duplicados o sobreescrituras
    if (!multiMeaningDict[wordLower]) {
        multiMeaningDict[wordLower] = { general: translation };
        console.log(`Nueva palabra aprendida: ${wordLower} -> ${translation}`);

        // Opcional: Guardar en localStorage para persistencia
        try {
            localStorage.setItem('learnedWords', JSON.stringify(multiMeaningDict));
        } catch (e) {
            console.error('Error saving to localStorage:', e);
        }
    }
}

        // ========== FUNCIONES DE TEXTO ==========
        async function saveText() {
            const name = textNameInput.value.trim();
            const content = textInput.value.trim();

            if (!name || !content) {
                alert('Please enter both a name and text content');
                return;
            }

            console.log('Saving text:', name);

            try {
                if (supabase) {
                    // Usar Supabase
                    const { data: existing, error: fetchError } = await supabase
                        .from('texts')
                        .select('id')
                        .eq('user_name', currentUser)
                        .eq('name', name)
                        .limit(1)
                        .maybeSingle();

                    if (fetchError) {
                        console.error('Fetch error:', fetchError);
                        return;
                    }

                    if (existing) {
                        alert('A text with this name already exists');
                        return;
                    }

                    const { error: insertError } = await supabase
                        .from('texts')
                        .insert({
                            user_name: currentUser,
                            name: name,
                            content: content,
                            created_at: new Date().toISOString()
                        })
                        .select();

                    if (insertError) {
                        console.error('Insert error:', insertError);
                        return;
                    }
                } else {
                    // Usar almacenamiento local
                    const existingIndex = texts.findIndex(t => t.name === name);
                    if (existingIndex !== -1) {
                        alert('A text with this name already exists');
                        return;
                    }
                    
                    texts.push({
                        name: name,
                        content: content,
                        created_at: new Date().toISOString()
                    });
                }

                textNameInput.value = '';
                textInput.value = '';

                await Promise.all([
                    renderSavedTexts(),
                    updateStats(),
                    extractWords(content)
                ]);

                console.log('Text saved successfully');

            } catch (error) {
                console.error('Error in save operation:', error);
            }
        }

        async function renderSavedTexts() {
            console.log('Rendering saved texts');
            
            try {
                if (supabase) {
                    const { data: userTexts, error } = await supabase
                        .from('texts')
                        .select('*')
                        .eq('user_name', currentUser)
                        .order('created_at', { ascending: false });

                    if (error) {
                        console.error('Error loading texts:', error);
                        return;
                    }
                    texts = userTexts || [];
                }

                savedTextsList.innerHTML = '';

                if (texts.length === 0) {
                    savedTextsList.innerHTML = '<p class="text-gray-500 col-span-2 text-center py-4">No saved texts yet</p>';
                    return;
                }
                    
                texts.forEach(text => {
                    const textCard = document.createElement('div');
                    textCard.className = 'bg-gray-50 p-3 rounded-lg border border-gray-200 hover:border-indigo-300 transition cursor-pointer';
                    textCard.innerHTML = `
                        <h3 class="font-medium text-gray-800 truncate">${text.name}</h3>
                        <p class="text-sm text-gray-500 mt-1">${new Date(text.created_at).toLocaleDateString()}</p>
                        <div class="flex justify-end mt-2">
                            <button class="text-indigo-600 hover:text-indigo-800 mr-2 view-text-btn" data-name="${text.name}">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button class="text-red-600 hover:text-red-800 delete-text-btn" data-name="${text.name}">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                    savedTextsList.appendChild(textCard);
                });
                
                document.querySelectorAll('.view-text-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        viewText(btn.getAttribute('data-name'));
                    });
                });
                
                document.querySelectorAll('.delete-text-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteText(btn.getAttribute('data-name'));
                    });
                });
                
            } catch (error) {
                console.error('Error rendering saved texts:', error);
            }
        }

        async function viewText(name) {
            console.log('Viewing text:', name);
            
            const text = texts.find(t => t.name === name);
            if (!text) return;

            selectedText = text;
            currentTextTitle.textContent = text.name;

            await loadWordInventory();

            let processedContent = text.content;
            const words = processedContent.split(/(\s+|[.,\/#!$%\^&\*;:{}=\-_`~()]+)/);

            processedContent = words.map(word => {
                if (/^\s+$/.test(word) || /^[.,\/#!$%\^&\*;:{}=\-_`~()]+$/.test(word)) {
                    return word;
                }

                const cleanWord = word.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '').toLowerCase();
                if (cleanWord.trim() === '') return word;

                const status = wordInventory[cleanWord]?.status;

                let wordClass = '';
                if (status === 'known') wordClass = 'known';
                if (status === 'forgotten') wordClass = 'forgotten';

                return `<span class="word ${wordClass}" data-word="${cleanWord}">${word}<span class="word-actions" style="opacity: 1;">
                    <button class="speech-btn" data-word="${cleanWord}" title="Pronunciar palabra">
                        <i class="fas fa-volume-up"></i>
                    </button>
                    <button class="mark-known-btn" data-word="${cleanWord}" title="Marcar como conocida">
                        <i class="fas fa-check"></i>
                    </button>
                    <button class="mark-forgotten-btn" data-word="${cleanWord}" title="Marcar como olvidada">
                        <i class="fas fa-exclamation"></i>
                    </button>
                </span></span>`;
            }).join('');

            textDisplay.innerHTML = processedContent;

            // Event listeners para los botones
            document.querySelectorAll('.speech-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const word = btn.getAttribute('data-word');
                    speakWord(word);
                });
            });

            document.querySelectorAll('.mark-known-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedWord = btn.getAttribute('data-word');
                    markWordAndUpdate('known', btn);
                });
            });

            document.querySelectorAll('.mark-forgotten-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedWord = btn.getAttribute('data-word');
                    markWordAndUpdate('forgotten', btn);
                });
            });

            textViewerSection.classList.remove('hidden');
        }

        async function loadWordInventory() {
            try {
                if (supabase) {
                    const { data, error } = await supabase
                        .from('word_inventory')
                        .select('word, status')
                        .eq('user_name', currentUser);

                    if (error) {
                        console.error('Error loading word inventory:', error);
                        return;
                    }

                    wordInventory = {};
                    data.forEach(entry => {
                        wordInventory[entry.word] = {
                            status: entry.status
                        };
                    });
                }
            } catch (error) {
                console.error('Error loading word inventory:', error);
            }
        }

        function closeText() {
            textViewerSection.classList.add('hidden');
            selectedText = null;
            selectedWord = null;
            selectedRange = null;
            translationResult.classList.add('hidden');
        }

        async function deleteText(name) {
            if (confirm(`Are you sure you want to delete "${name}"?`)) {
                try {
                    if (supabase) {
                        const { error } = await supabase
                            .from('texts')
                            .delete()
                            .eq('user_name', currentUser)
                            .eq('name', name);

                        if (error) {
                            console.error('Error deleting text:', error);
                            return;
                        }
                    } else {
                        const index = texts.findIndex(t => t.name === name);
                        if (index !== -1) {
                            texts.splice(index, 1);
                        }
                    }

                    await renderSavedTexts();
                    await updateStats();
                    
                    if (selectedText && selectedText.name === name) {
                        closeText();
                    }
                    
                    console.log('Text deleted successfully');
                } catch (error) {
                    console.error('Error deleting text:', error);
                }
            }
        }

        // ========== FUNCIONES DE PALABRAS ==========
        async function markWordAndUpdate(status, buttonElement) {
            if (!selectedWord) return;

            await markWord(status);
            
            const wordSpan = buttonElement.closest('.word');
            if (wordSpan) {
                wordSpan.classList.remove('known', 'forgotten');
                if (status === 'known') {
                    wordSpan.classList.add('known');
                } else if (status === 'forgotten') {
                    wordSpan.classList.add('forgotten');
                }
            }
        }

        async function markWord(status) {
            if (!selectedWord) return;

            try {
                if (supabase) {
                    const { data: existingWord } = await supabase
                        .from('word_inventory')
                        .select('*')
                        .eq('user_name', currentUser)
                        .eq('word', selectedWord)
                        .limit(1)
                        .maybeSingle();

                    if (existingWord) {
                        await supabase
                            .from('word_inventory')
                            .update({
                                status: status,
                                count: existingWord.count + 1,
                                last_updated: new Date().toISOString()
                            })
                            .eq('id', existingWord.id);
                    } else {
                        await supabase
                            .from('word_inventory')
                            .insert([{
                                user_name: currentUser,
                                word: selectedWord,
                                status: status,
                                count: 1,
                                last_updated: new Date().toISOString()
                            }]);
                    }
                } else {
                    // Usar almacenamiento local
                    wordInventory[selectedWord] = { status: status };
                }

                await Promise.all([
                    renderWordInventory(),
                    updateStats()
                ]);

            } catch (error) {
                console.error('Error marking word:', error);
            }
        }

    // Extraer palabras de un texto y actualizar el inventario
    async function extractWords(text) {
    // Extraer todas las palabras en minúsculas
    const words = text.toLowerCase().match(/\b[\w']+\b/g) || [];

    for (const word of words) {
        // Limpiar signos de puntuación
        const cleanWord = word.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');

        if (supabase) {
            // Verificar si la palabra ya existe para el usuario actual
            const { data: existingWord } = await supabase
                .from('word_inventory')
                .select('id, count')
                .eq('user_name', currentUser)
                .eq('word', cleanWord)
                .maybeSingle();

            if (existingWord) {
                // Si existe, aumentar el contador y actualizar fecha
                await supabase
                    .from('word_inventory')
                    .update({
                        count: existingWord.count + 1,
                        last_updated: new Date().toISOString()
                    })
                    .eq('id', existingWord.id);
            } else {
                // Si no existe, crear un nuevo registro con estado "new"
                await supabase
                    .from('word_inventory')
                    .insert([{
                        user_name: currentUser,
                        word: cleanWord,
                        status: 'new',
                        count: 1,
                        last_updated: new Date().toISOString()
                    }]);
            }
        } else {
            // Si no se usa Supabase, actualizar inventario en memoria
            if (!wordInventory[cleanWord]) {
                wordInventory[cleanWord] = { status: 'new' };
            }
        }
    }

    // Actualizar interfaz después de procesar todas las palabras
    await renderWordInventory();
    await updateStats();
}

        // ========== FUNCIONES DE ESTADÍSTICAS ==========
        async function updateStats() {
            try {
                let knownWords = 0, forgottenWords = 0, totalWords = 0, totalTexts = 0;

                if (supabase) {
                    const { count: known } = await supabase
                        .from('word_inventory')
                        .select('*', { count: 'exact' })
                        .eq('user_name', currentUser)
                        .eq('status', 'known');

                    const { count: forgotten } = await supabase
                        .from('word_inventory')
                        .select('*', { count: 'exact' })
                        .eq('user_name', currentUser)
                        .eq('status', 'forgotten');

                    const { count: total } = await supabase
                        .from('word_inventory')
                        .select('*', { count: 'exact' })
                        .eq('user_name', currentUser);

                    const { count: textsTotal } = await supabase
                        .from('texts')
                        .select('*', { count: 'exact' })
                        .eq('user_name', currentUser);

                    knownWords = known || 0;
                    forgottenWords = forgotten || 0;
                    totalWords = total || 0;
                    totalTexts = textsTotal || 0;
                } else {
                    // Usar datos locales
                    const words = Object.values(wordInventory);
                    knownWords = words.filter(w => w.status === 'known').length;
                    forgottenWords = words.filter(w => w.status === 'forgotten').length;
                    totalWords = words.length;
                    totalTexts = texts.length;
                }

                knownCount.textContent = knownWords;
                forgottenCount.textContent = forgottenWords;
                totalCount.textContent = totalWords;
                textsCount.textContent = totalTexts;

                const progress = totalWords > 0 ? Math.round((knownWords / totalWords) * 100) : 0;
                progressBar.style.width = `${progress}%`;
                progressPercentage.textContent = `${progress}%`;
                
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        async function renderWordInventory(filter = '') {
            try {
                let words = [];

                if (supabase) {
                    let query = supabase
                        .from('word_inventory')
                        .select('*')
                        .eq('user_name', currentUser);

                    if (filter) {
                        query = query.ilike('word', `%${filter}%`);
                    }

                    const { data, error } = await query;

                    if (error) {
                        console.error('Error loading words:', error);
                        return;
                    }
                    words = data || [];
                } else {
                    // Usar datos locales
                    words = Object.entries(wordInventory)
                        .filter(([word]) => !filter || word.includes(filter.toLowerCase()))
                        .map(([word, data]) => ({ word, ...data }));
                }

                wordInventoryTable.innerHTML = '';

                if (words.length === 0) {
                    wordInventoryTable.innerHTML = `
                        <tr>
                            <td colspan="2" class="px-2 py-4 text-center text-gray-500">No words found</td>
                        </tr>
                    `;
                    return;
                }

                words.forEach(wordData => {
                    const row = document.createElement('tr');

                    let statusClass = '';
                    let statusText = '';

                    if (wordData.status === 'known') {
                        statusClass = 'bg-green-100 text-green-800';
                        statusText = 'Known';
                    } else if (wordData.status === 'forgotten') {
                        statusClass = 'bg-orange-100 text-orange-800';
                        statusText = 'Forgotten';
                    } else {
                        statusClass = 'bg-gray-100 text-gray-800';
                        statusText = 'New';
                    }

                    row.innerHTML = `
                        <td class="px-2 py-2 whitespace-nowrap font-medium">${wordData.word}</td>
                        <td class="px-2 py-2 whitespace-nowrap">
                            <span class="px-2 py-1 text-xs rounded-full ${statusClass}">${statusText}</span>
                        </td>
                    `;

                    wordInventoryTable.appendChild(row);
                });

            } catch (error) {
                console.error('Error rendering word inventory:', error);
            }
        }

        function searchWords() {
            const query = searchWord.value.trim();
            renderWordInventory(query);
        }

        // ========== FUNCIONES DE PRÁCTICA ==========
        async function generatePracticeList() {
    const count = parseInt(wordCount.value) || 5;
    currentPracticeWords = [];

    practiceWords.innerHTML = '<div class="practice-word-card loading-card"><i class="fas fa-spinner fa-spin mr-2"></i>Loading translations...</div>';
    practiceList.classList.remove('hidden');

    console.log('Generating practice list. Supabase available:', !!supabase);
    console.log('Current word inventory:', wordInventory);

    try {
        let availableWords = [];

        if (supabase) {
            const { data: words, error } = await supabase
                .from('word_inventory')
                .select('word')
                .eq('user_name', currentUser)
                .neq('status', 'known')
                .limit(count * 2);

            if (error) {
                console.error('Supabase error:', error);
                throw error;
            }

            availableWords = words || [];
            console.log('Words from Supabase:', availableWords);
        } else {
            // Usar datos locales
            console.log('Using local word inventory');
            availableWords = Object.entries(wordInventory)
                .filter(([word, data]) => {
                    console.log(`Word: ${word}, Status: ${data.status}`);
                    return data.status !== 'known';
                })
                .slice(0, count * 2)
                .map(([word]) => ({ word }));

            console.log('Available words from local:', availableWords);
        }

        if (availableWords.length === 0) {
            practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-gray-500 text-center">No words available for practice!</p></div>';
            return;
        }

        const shuffledWords = availableWords.sort(() => 0.5 - Math.random());
        console.log('Shuffled words:', shuffledWords);

        for (const wordObj of shuffledWords) {
            if (currentPracticeWords.length >= count) break;

            const word = wordObj.word;
            const translationObj = await translateWordToSpanish(word);
            const formattedTranslation = formatTranslation(translationObj);

            console.log(`Word: ${word}, Translation: ${formattedTranslation.text}`);

            if (formattedTranslation.text) {
                currentPracticeWords.push({
                    word,
                    translation: formattedTranslation.html,
                    plainTranslation: formattedTranslation.text
                });
            }
        }

        console.log('Final practice words:', currentPracticeWords);
        renderPracticeWords();

    } catch (error) {
        console.error('Error generating practice list:', error);
        practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-red-500 text-center">Error loading practice words</p></div>';
    }
}

        // ========== FUNCIONES DE PRÁCTICA ==========
        async function generateVerbPracticeList() {
            const count = parseInt(wordCount.value) || 5;
            currentPracticeWords = [];

            practiceWords.innerHTML = '<div class="practice-word-card loading-card"><i class="fas fa-spinner fa-spin mr-2"></i>Loading verb translations...</div>';
            practiceList.classList.remove('hidden');

            console.log('Generating verb practice list');

            try {
                let availableWords = [];

                if (supabase) {
                    const { data: words, error } = await supabase
                        .from('word_inventory')
                        .select('word')
                        .eq('user_name', currentUser)
                        .neq('status', 'known')
                        .limit(count * 3);

                    if (error) {
                        console.error('Supabase error:', error);
                        throw error;
                    }

                    availableWords = words || [];
                } else {
                    // Usar datos locales
                    availableWords = Object.entries(wordInventory)
                        .filter(([word, data]) => data.status !== 'known')
                        .slice(0, count * 3)
                        .map(([word]) => ({ word }));
                }

                if (availableWords.length === 0) {
                    practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-gray-500 text-center">No words available for verb practice!</p></div>';
                    return;
                }

                const shuffledWords = availableWords.sort(() => 0.5 - Math.random());

                for (const wordObj of shuffledWords) {
                    if (currentPracticeWords.length >= count) break;

                    const word = wordObj.word;
                    const translation = await translateWordToSpanish(word, true);

                    if (translation && translation !== word.toLowerCase()) {
                        currentPracticeWords.push({ word, translation });
                    }
                }

                renderPracticeWords();

            } catch (error) {
                console.error('Error generating verb practice list:', error);
                practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-red-500 text-center">Error loading verb practice words</p></div>';
            }
        }

function renderPracticeWords() {
    practiceWords.innerHTML = '';

    if (currentPracticeWords.length === 0) {
        practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-gray-500 text-center">No words with valid translations found</p></div>';
        return;
    }

    currentPracticeWords.forEach(({ word, translation }, index) => {
        const wordCard = document.createElement('div');
        wordCard.className = 'practice-word-card';
        wordCard.innerHTML = `
            <div class="word-original">${word}</div>
            <div class="word-translation">${translation}</div>
            <div class="practice-card-actions">
                <button class="speak-practice-btn" data-word="${word}" title="Pronunciar">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button class="mark-practice-known-btn" data-word="${word}" data-index="${index}" title="Marcar como conocido">
                    <i class="fas fa-check"></i>
                </button>
            </div>
        `;
        practiceWords.appendChild(wordCard);
    });

    // Event listeners para practice cards
    document.querySelectorAll('.speak-practice-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const word = btn.getAttribute('data-word');
            speakWord(word);
        });
    });

    document.querySelectorAll('.mark-practice-known-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const word = btn.getAttribute('data-word');
            const index = parseInt(btn.getAttribute('data-index'));
            markPracticeWordAsKnown(word, index);
        });
    });
}

        async function markPracticeWordAsKnown(word, index) {
            selectedWord = word;
            await markWord('known');

            currentPracticeWords.splice(index, 1);
            renderPracticeWords();

            if (currentPracticeWords.length === 0) {
                practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-green-500 text-center font-semibold"><i class="fas fa-trophy mr-2"></i>All practice words completed!</p></div>';
            }
        }

        async function markAllPracticeWordsAsKnown() {
            if (currentPracticeWords.length === 0) return;

            for (const { word } of currentPracticeWords) {
                selectedWord = word;
                await markWord('known');
            }

            currentPracticeWords = [];
            practiceWords.innerHTML = '<div class="practice-word-card"><p class="text-green-500 text-center font-semibold"><i class="fas fa-trophy mr-2"></i>All words marked as known!</p></div>';
        }

        function shufflePracticeWords() {
            if (currentPracticeWords.length === 0) return;

            currentPracticeWords.sort(() => 0.5 - Math.random());
            renderPracticeWords();
        }

// Función principal para reproducir todas las palabras de práctica
async function playAllPracticeWords() {
    if (currentPracticeWords.length === 0) {
        alert('No practice words available!');
        return;
    }

    playPracticeLoop.disabled = true;
    playPracticeLoop.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Playing...';

    await delay(800); // Pausa inicial para dar tiempo al sintetizador

    try {
        for (let i = 0; i < currentPracticeWords.length; i++) {
            const { word, plainTranslation } = currentPracticeWords[i];

            highlightCurrentPracticeWord(i);

            // 1. Pronunciar palabra en inglés (más lento)
            await speakWordAsync(word, 'en-US', 0.7);
            await delay(1500);

            // 2. Pronunciar traducción en español con categorías
            await speakTranslationWithCategories(plainTranslation);
            await delay(1000);

            removeHighlightFromPracticeWord(i);
        }
    } catch (error) {
        console.error('Error playing practice words:', error);
    } finally {
        playPracticeLoop.disabled = false;
        playPracticeLoop.innerHTML = '<i class="fas fa-play-circle mr-1"></i> Listen All';
    }
}

// Nueva función para pronunciar traducciones con categorías
async function speakTranslationWithCategories(plainTranslation) {
    if (!plainTranslation) return;

    // Detectar si tiene categorías (Sustantivo: ... Verbo: ...)
    if (plainTranslation.includes('Sustantivo:') || plainTranslation.includes('Verbo:')) {
        const parts = plainTranslation.split(/\.\s*(?=Sustantivo:|Verbo:)/g).filter(part => part.trim());

        for (const part of parts) {
            const trimmedPart = part.trim();
            if (!trimmedPart) continue;

            if (trimmedPart.startsWith('Sustantivo:')) {
                const content = trimmedPart.replace('Sustantivo:', '').trim();
                await speakWordAsync('sustantivo', 'es-ES', 0.8);
                await delay(300);
                await speakCleanTranslation(content);
            } else if (trimmedPart.startsWith('Verbo:')) {
                const content = trimmedPart.replace('Verbo:', '').trim();
                await speakWordAsync('verbo', 'es-ES', 0.8);
                await delay(300);
                await speakCleanTranslation(content);
            }

            await delay(800);
        }
    } else {
        // Si no tiene categorías, pronunciar directamente
        await speakCleanTranslation(plainTranslation);
    }
}

// Función para limpiar y pronunciar traducciones
async function speakCleanTranslation(text) {
    const cleanText = cleanForSpeech(text);
    // Dividir por comas y pronunciar cada parte
    const parts = cleanText.split(',').map(part => part.trim()).filter(part => part);

    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        await speakWordAsync(part, 'es-ES', 0.8);
        if (i < parts.length - 1) await delay(400); // Pausa entre partes
    }
}

// Función mejorada para limpiar texto para pronunciación
function cleanForSpeech(text) {
    if (!text) return '';

    let clean = text
        // Eliminar etiquetas HTML
        .replace(/<[^>]+>/g, '')
        // Reemplazar barras por comas para pausas naturales
        .replace(/\s*\/\s*/g, ', ')
        // Eliminar abreviaciones problemáticas SOLO cuando son abreviaturas
        .replace(/\bsust\.\b/gi, 'sustantivo')
        .replace(/\bverb\.\b/gi, 'verbo')
        .replace(/\bnoun\.\b/gi, 'sustantivo')
        // Eliminar espacios múltiples
        .replace(/\s+/g, ' ')
        .trim();

    return clean;
}

async function speakParts(text) {
    const cleanText = cleanForSpeech(text);
    // Dividir por comas o barras y pronunciar cada parte con pausa
    const parts = cleanText.split(/,|\//).map(part => part.trim()).filter(part => part);

    for (const part of parts) {
        await speakWordAsync(part, 'es-ES', 0.8); // Velocidad reducida
        if (parts.length > 1) await delay(500); // Pausa solo si hay múltiples partes
    }
}

        function highlightCurrentPracticeWord(index) {
            const cards = document.querySelectorAll('.practice-word-card');
            if (cards[index]) {
                cards[index].style.border = '3px solid #6366f1';
                cards[index].style.backgroundColor = '#f0f9ff';
            }
        }

        function removeHighlightFromPracticeWord(index) {
            const cards = document.querySelectorAll('.practice-word-card');
            if (cards[index]) {
                cards[index].style.border = '2px solid #e5e7eb';
                cards[index].style.backgroundColor = 'white';
            }
        }

        // ========== FUNCIONES DE AUDIO ==========
        function speakWord(word, lang = 'en-US') {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = lang;
                utterance.rate = 0.8;
                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('Speech synthesis not supported in your browser');
            }
        }

// Función actualizada para pronunciación asíncrona con velocidad configurable
function speakWordAsync(text, lang = 'en-US', rate = 0.8) {
    return new Promise((resolve) => {
        if (!('speechSynthesis' in window)) {
            console.warn('Speech synthesis not supported');
            resolve();
            return;
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = lang;
        utterance.rate = rate;

        utterance.onend = () => resolve();
        utterance.onerror = () => resolve();

        window.speechSynthesis.speak(utterance);
    });
}

// Función para crear el delay
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Función para generar y descargar audio de práctica
async function generateAndDownloadPracticeAudio() {
    if (currentPracticeWords.length === 0) {
        alert('No practice words available!');
        return;
    }

    // Función para limpiar texto de etiquetas HTML y entidades
    const cleanText = (txt) => {
        if (!txt) return '';
        return txt
            .replace(/<[^>]+>/g, ' ')
            .replace(/&[a-z]+;/gi, ' ')
            .replace(/\s+/g, ' ')
            .trim();
    };

    const audioChunks = [];
    for (const { word, translation } of currentPracticeWords) {
        // Inglés
        const enData = await generateSpeechAudio(cleanText(word), 'en-US', 0.9);
        console.log("EN:", word, "samples:", enData.length);
        audioChunks.push(enData);

        // Traducción al español (puede ser objeto o string)
        let textEs = (typeof translation === 'string')
    ? translation
    : (translation.general || Object.values(translation).join(', '));

textEs = cleanText(textEs);

// --- Normalizar completamente la categoría ---
let spokenEs = textEs
     // Convertir inglés a español
    .replace(/\bnoun\b[:.]?/gi, 'sustantivo ')
    .replace(/\bverb\b[:.]?/gi, 'verbo ')
    // Convertir abreviaturas
    .replace(/\bsust\b[:.]?/gi, 'sustantivo ')
    // Asegurar que Sustantivo: y Verbo: se lean bien
    .replace(/Sustantivo:/gi, 'sustantivo ')
    .replace(/Verbo:/gi, 'verbo ');

// Pequeña pausa inicial antes de reproducir el primer audio
await new Promise(r => setTimeout(r, 600));

const esData = await generateSpeechAudio(spokenEs, 'es-ES', 0.9);


        console.log("ES:", textEs, "samples:", esData.length);
        audioChunks.push(esData);
    }

    // Combinar fragmentos
    function concatenateFloat32Arrays(chunks) {
        let totalLength = 0;
        for (let chunk of chunks) totalLength += chunk.length;
        const result = new Float32Array(totalLength);
        let offset = 0;
        for (let chunk of chunks) {
            result.set(chunk, offset);
            offset += chunk.length;
        }
        return result;
    }

    const combined = concatenateFloat32Arrays(audioChunks);

    // Convertir a WAV
    const blob = audioArrayToWavBlob(combined, 22050);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'practice_words.wav';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Función para generar el blob de audio (VERSIÓN SEGURA)
async function generatePracticeAudioBlob() {
    const sampleRate = 22050;
    let allAudioData = [];

    try {
        for (let i = 0; i < currentPracticeWords.length; i++) {
            const { word, plainTranslation } = currentPracticeWords[i];

            console.log(`Processing word ${i + 1}: ${word}`);

            // Audio en inglés
            try {
                const englishAudio = await generateSpeechAudio(word, 'en-US', 0.7);
                if (englishAudio && Array.isArray(englishAudio) && englishAudio.length < 1000000) {
                    allAudioData = allAudioData.concat(Array.from(englishAudio));
                }
            } catch (e) {
                console.error('Error with English audio:', e);
            }

            // Silencio 1.5 segundos
            const silence1 = Array.from(generateSilence(sampleRate * 1.5));
            allAudioData = allAudioData.concat(silence1);

            // Audio en español - SIMPLIFICADO
            try {
                const cleanText = cleanForSpeech(plainTranslation || '');
                if (cleanText) {
                    const spanishAudio = await generateSpeechAudio(cleanText, 'es-ES', 0.8);
                    if (spanishAudio && Array.isArray(spanishAudio) && spanishAudio.length < 1000000) {
                        allAudioData = allAudioData.concat(Array.from(spanishAudio));
                    }
                }
            } catch (e) {
                console.error('Error with Spanish audio:', e);
            }

            // Silencio entre palabras
            if (i < currentPracticeWords.length - 1) {
                const silence2 = Array.from(generateSilence(sampleRate * 2));
                allAudioData = allAudioData.concat(silence2);
            }
        }

        console.log('Total audio data length:', allAudioData.length);
        return audioArrayToWavBlob(new Float32Array(allAudioData), sampleRate);

    } catch (error) {
        console.error('Error in generatePracticeAudioBlob:', error);
        throw error;
    }
}

// Función corregida para generar audio real usando Google Cloud TTS
async function generateSpeechAudio(text, lang, rate) {
    const API_KEY = 'AIzaSyAfh1qmYevSKOK_a3mw3B5-JX76hkNpBcM';

    try {
        const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                input: { text: text },
                voice: {
                    languageCode: lang,
                    name: lang === 'en-US' ? 'en-US-Wavenet-D' : 'es-ES-Wavenet-B',
                    ssmlGender: 'NEUTRAL'
                },
                audioConfig: {
                    audioEncoding: 'LINEAR16',
                    speakingRate: rate,
                    sampleRateHertz: 22050
                }
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Google TTS API error: ${response.status} - ${errorText}`);
            throw new Error(`Google TTS API error: ${response.status}`);
        }

        const data = await response.json();

        if (!data.audioContent) {
            console.error('No audio content returned from Google TTS');
            return generateSilence(22050); // 1 segundo de silencio como fallback
        }

        console.log(`Audio generated for: "${text}" (${lang})`);

        // Convertir base64 a ArrayBuffer
        const binaryString = atob(data.audioContent);
        const audioBuffer = new ArrayBuffer(binaryString.length);
        const audioView = new Uint8Array(audioBuffer);

        for (let i = 0; i < binaryString.length; i++) {
            audioView[i] = binaryString.charCodeAt(i);
        }

        // Convertir a Float32Array (LINEAR16 es 16-bit signed)
        const audioData = new Int16Array(audioBuffer);
        const floatArray = new Float32Array(audioData.length);

        for (let i = 0; i < audioData.length; i++) {
            floatArray[i] = audioData[i] / 32768.0; // Normalizar de -32768/32767 a -1.0/1.0
        }

        console.log(`Converted audio length: ${floatArray.length} samples`);
        return floatArray;

    } catch (error) {
        console.error('Error generating speech audio:', error);
        // Fallback a silencio si falla
        return generateSilence(22050);
    }
}

// Función para generar silencio (CORREGIDA)
function generateSilence(samples) {
    const silenceArray = new Float32Array(Math.floor(samples));
    // Ya está lleno de ceros por defecto, no necesita bucle
    return silenceArray;
}

// Función mejorada para convertir array de audio a WAV blob
function audioArrayToWavBlob(audioData, sampleRate) {
    const length = audioData.length;
    const buffer = new ArrayBuffer(44 + length * 2);
    const view = new DataView(buffer);

    // Función auxiliar para escribir strings
    const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };

    // WAV header mejorado
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);         // PCM format
    view.setUint16(20, 1, true);          // Audio format (PCM)
    view.setUint16(22, 1, true);          // Number of channels (mono)
    view.setUint32(24, sampleRate, true); // Sample rate
    view.setUint32(28, sampleRate * 2, true); // Byte rate
    view.setUint16(32, 2, true);          // Block align
    view.setUint16(34, 16, true);         // Bits per sample
    writeString(36, 'data');
    view.setUint32(40, length * 2, true);

    // Escribir datos de audio con mejor calidad
    let offset = 44;
    for (let i = 0; i < length; i++) {
        // Normalizar y aplicar dithering básico
        let sample = Math.max(-1, Math.min(1, audioData[i]));
        sample = sample * 0x7FFF;
        view.setInt16(offset, sample, true);
        offset += 2;
    }

    return new Blob([buffer], { type: 'audio/wav' });
}

// Función para descargar el archivo con nombre mejorado
function downloadAudioFile(blob, filename) {
    const timestamp = new Date().toISOString().slice(0, 10);
    const finalFilename = `english-practice-${timestamp}.wav`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = finalFilename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`Audio file downloaded: ${finalFilename}`);
}


        // ========== INICIALIZACIÓN FINAL ==========
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing application...');

            initializeDOMElements();

            if (mainApp) mainApp.style.display = 'none';
            if (loginContainer) loginContainer.style.display = 'flex';

            initLogin();

            console.log("Aplicación inicializada correctamente");
        });
    </script>
</body>
</html>